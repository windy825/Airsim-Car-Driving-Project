# 0. 장애물 파트

#### 목차

<br>

- [1. 장애물 분석 연구](#1-장애물-분석-연구)

<br>

- [2. 도로 정보를 2차원 map으로 표현하기](#2-도로-정보를-2차원-map으로-표현하기)
     - 1. 기본설계 - 기본 도로 형태 반영을 위한 준비
     - 2. 중앙선 점 좌표 구하기
     - 3. 중앙선 점을 어떤 방식으로 좌표로 표현할 수 있는가?
     - 4. 도로 정보 및 장애물 표현하기

<br>

- [3. 2차원 MAP 기반, 장애물 극복 경로 찾기](#3-2차원-MAP-기반-장애물-극복-경로-찾기)
     - 1차 시도 : 장애물 기반으로, 가능한 경로 수집
     - 이슈 1 : 점으로 표현된 장애물 정보는 실제 크기를 반영하는가 ?
     - 이슈 2 : 차량각도가 항상 전방 수직으로 표현되는게 맞는가 ?

<br>

- [4. 발생한 문제와 해결방안](#4-발생한-문제와-해결방안)
     - 받아오는 API 값이 튄다.
     - 도로정보가 곡선일때, 왜곡된다.

<br>

<br>

# 1. 장애물 분석 연구 

**주행 코스에는 여러가지 장애물들이 펼쳐저 있는데, 크게 종류는 단일, 복합, 다중 3가지 이다.**

**이번 프로젝트를 진행하면서 매우 다양한 어려움을 만났다. 그 어려움들을 극복한 방식과**

**연구결과 및 접근방식을 소개하고자 한다.**

<br>

<br>

#### 단일 방식

![KakaoTalk_20220821_160205917](https://user-images.githubusercontent.com/89068148/185780140-0e1514f1-20c2-4d88-9ec1-ecaeeccc928f.jpg)

가장 흔한 방식의 장애물, 전체 장애물 중 60%을 차지함.

이 경우, 차량 주행 운신의 폭이 넓고, 가능한 경우의 수가 많기 때문에 쉽게 극복 가능

<br>

#### 복합 방식

![KakaoTalk_20220821_160205917](https://user-images.githubusercontent.com/89068148/185780199-c05f9e1b-5dd7-420b-831a-07e73ad4f16b.jpg)

단순히 장애물의 갯수가 늘어난 방식으로, 차량이 지나갈 수 있는 경로의 가짓수가 줄어들 뿐, 

극복 자체는 쉬운 편

<br>

![KakaoTalk_20220821_160205917](https://user-images.githubusercontent.com/89068148/185780240-c1b29a12-1e77-4343-997f-1e8877c4ed23.jpg)

위의 경우처럼 장애물의 갯수가 늘어난 방식이나, 극복 가능한 경우를 1가지로 제한한 경우로, 
경로 분석을 통해 가능한 경로 1지점을 찾아내야 함.

<br>

<br>

#### 다중 방식

![KakaoTalk_20220821_160205917](https://user-images.githubusercontent.com/89068148/185780266-66e8bebd-f7a8-4ced-a4c9-6e1c77d34c7d.jpg)

<br>

<br>

# 2. 도로 정보를 2차원 map으로 표현하기

<br>

#### 1. 기본설계 - 기본 도로 형태 반영을 위한 준비

```
도로 폭 : 중앙선 점 기준으로 좌우 일정 m 씩 떨어진 형태 (주행코스 별 상이)
         여기선 임의로 10m 로 표시
```

<br>![KakaoTalk_20220821_180157534](https://user-images.githubusercontent.com/89068148/185783791-824effb9-69c4-4632-a575-d1be8b5707d5.jpg)

도로의 중앙선의 점들의 좌표를 구할 수 있다면, 그림처럼 중앙좌표(a,b,c,d)를 기준으로 

좌우로 도로폭(10m) 의 절반(5m)씩 뻗어 나가면 도로의 형태를 그릴 수 있다.

그림의 경우로 보자면, 시뮬레이터에서 api로 제공하는 정보들을 이용하여,  중앙선의 점들의

좌표를 가져온다.

<br>

![KakaoTalk_20220821_162832831_07](https://user-images.githubusercontent.com/89068148/185783950-c687ba52-f11c-47e3-8514-5f0b3adf09c3.jpg)

2차원 배열을 MAP이라고 할때,

각 원소는 1m의 정사각형을 나타낸다.

따라서 각 중앙점 a, b, c, d으로부터 좌우 5칸은 도로의 좌우 간격이 각각 5m임을 표현한다.

<br>

![KakaoTalk_20220821_162832831_07](https://user-images.githubusercontent.com/89068148/185784183-dcaaab54-8819-45d3-85ce-d377a2e7250d.jpg)

예시로 위의 그림에서 차량의 중앙점은 `MAP[11][5]` 으로 나타낼 수 있다.

<br>

<br>

#### 2. 중앙선 점 좌표 구하기

그렇다면, 도로의 중앙점의 좌표를 어떻게 받아 올 수 있을까?

장애물, 도로폭 등 모든 정보가 그 지점들을 기준으로 펼쳐지기 때문에,

결국엔 2차원 배열형태의 MAP으로 표현하기 위해선 중앙선 위의 점들인 way_points의 정확한

좌표정보가 있어야 가능했다.



사용된 api 정보는 다음과 같다.

**to_middle 과 moving_angle**

![KakaoTalk_20220821_185319378](https://user-images.githubusercontent.com/89068148/185785566-b713130a-b488-4014-a4aa-1e0fc6dff9fe.jpg)

`to_middle` 의 경우 내차의 중심점이 도로 중앙선에서 수직으로 떨어진 거리이다.

`moving_angle` 은 현재 차량이 위치한 지점에서 가장 가까운 지점의 중앙선과 얼마나 각도가 차이나는지 이다.

​                            왼쪽방향일 경우, 음수 반대는 양수의 값을 가진다.

<br>

**track_forward_angles**

![KakaoTalk_20220821_191142370](https://user-images.githubusercontent.com/89068148/185786202-8da22a5e-4c8a-4728-985f-110f1c196b43.jpg)

현재 차량 위치 기준, 전방의 10개 구간에 대한 각도 정보
구간은 10m, 

양수일 경우, 현재 차량위치에서 오른쪽으로 기우는 도로
음수일 경우, 현재 기준으로 왼쪽으로 기우는 도로의 형태를 가진다.

다시말해 각도의 차이가 급격히 커질수록 도로가 급격히 휘어지는 형태이다.

<br>

**distance_to_way_points**

![KakaoTalk_20220821_185406830](https://user-images.githubusercontent.com/89068148/185785567-b9f39223-c731-4743-a927-5ddfc6e6e680.jpg)

way-points는 차량이 위치한 지점에서 전방 10m 간격으로 존재하는 중앙선 위의 점이다.
현재 차량에서 해당 점들과의 직선거리 정보를 가진다.

이때 10m 구간들은 아래처럼 정확한 직선의 형태로 받아온다고 가정하고 진행했다.

![KakaoTalk_20220821_192810555](https://user-images.githubusercontent.com/89068148/185786768-85c7843d-a7b6-47ff-8f80-7050696eb8df.jpg)

다시말해, 곡선의 형태로 곡선의 길이가 아닌, 위치 간의 직선거리이다. 

그러나, 이 가정은 **오차를 발생시키는 원인**이 되었다.



<br>

**생각해볼 점)  api 데이터, 정확한 분석의 중요성**

```
질좋은 차량의 상태 데이터들을 얻을 수 있다고 해도, 잘못된 접근과 
해석을 통해 자율 주행을 구현한다면, 뛰어난 이론이 적용된 것이라 하더라도 무쓸모 하다고 생각했다.

이번 프로젝트에서 api 데이터들을 이용해서 전체 도로 정보를 표현할 때 느낄 수 있었다.
도로 곡선 형태와 중앙선 위치 등의 정보를 가공하여 2차원 배열로 표현했을때, 
사소한 오차나 데이터에 대한 약간의 잘못된 해석만 첨가되기만 해도 도로의 형태가 실제 도로의 모습과 굉장한 차이가 났다.
```

<br>

<br>

#### 3. 중앙선 점을 어떤 방식으로 좌표로 표현할 수 있는가?

```
우리가 이용할 수 있는 api 데이터는 단순하게 위치 간 거리만 알 수 있을 뿐이었고, 
이것들을 정확히 좌표로 표현하여 2차원 배열로 찍어낸다는 것은 사실 불가능에 가까웠다고 생각했다.

그러나, 해당 정보들을 2차원 배열로 찍어 낼 수 만 있다면, 
장애물 극복이나, 도로의 곡선 형태에 따른 주행 제어 측면에서 정확도와 안정성에 큰 기여를 할 수 있다고 판단했다.
```

![KakaoTalk_20220821_183401198](https://user-images.githubusercontent.com/89068148/185785952-09ae9304-9911-41d3-a327-22c6cab131e3.jpg)

빨간지점은 각 중앙선 위의 way_points 점들이다. 

동시에 차량의 좌표에서의 상대적인 위치좌표를 구해야 할 대상이기도 했다.

따라서 얻어내야 할 정보는 **내 차량의 중심을 2차원 좌표로 나태내었을때, 그 좌표에서의  x값 차이와 y값 차이**이다.



![KakaoTalk_20220821_183401198_01](https://user-images.githubusercontent.com/89068148/185785953-74e12cd6-a7f8-4c58-b05c-2d8159b81abd.jpg)

먼저 차량 중심과 각 way_points들을 지점으로 하는 삼각형을 나타내었다.

여기서 `각 c`를 구하기 위한 그림인데, 먼저 점선으로 표현된 선은 차량의 방향각도를 중앙선으로 가져온 선이다.

따라서 **빨간점 사이의 직선이 중앙선**을 의미하고, **점선은 차량의 현재 진행각도를 표현한 직선**이다.

`angles` 배열은 api데이터 중 현재 차량위치를 중심으로 표현된 전방 20개 way_points에 대한 각도를 나타낸다.

따라서 그림에 표현된 것과 같이 `bo[i]`와 `각c` 사이의 각은 바로 다음 way_point의 `angles` 각에서 전 way_point지점의 `angles`각을 뺀 각과 같다.

따라서 `각c`의 경우 위 그림에 적힌 수식과 같다.

![KakaoTalk_20220821_204211216](https://user-images.githubusercontent.com/89068148/185789419-9d051ec6-89b7-4ff7-9ceb-ac9304c36e39.jpg)

여기서 `points` 배열은 api데이터중 `distance_to_way_points` 를 의미한다.

이번엔 `각A`를 구할 차례이다.

삼각형에서 **한 각과 마주보는 변의 길이의 비율은 모든 꼭지점 각에서 동일**하다.

따라서 구하려는 `각A`는 그림과 같이 표현할 수 있다.

  

![KakaoTalk_20220821_183401198_03](https://user-images.githubusercontent.com/89068148/185785956-16f7dfcf-0aeb-4e84-8a79-6a6980e2ad92.jpg)

따라서 `way_points`(중앙선 점) 들을 삼각형의 꼭지점으로 하고, 

반대쪽 차량의 중심인 `ts`의 각도를 구할 수 있었다.

위 그림에서 `ts`지점의 각도는 앞서 구한 `각c`,  `각a`를 이용해서 구할 수 있다.



![KakaoTalk_20220821_183401198_04](https://user-images.githubusercontent.com/89068148/185785946-296cbf6d-e971-451e-acbe-bf62bc51fd2d.jpg)

앞서 구한 방식으로 다른 모든 중앙점들의  경우에도 

`way_points` 에 대한 차량의 각도를 나타낼 수 있다.

![KakaoTalk_20220821_183401198_05](https://user-images.githubusercontent.com/89068148/185785947-d8f47e11-44b2-46b9-a24b-1dbf6f993be0.jpg)

사슬처럼 연계된 방식이다. 

앞서 구한 삼각형 윗 각은 다음 계산시, `bo[i]`로 표현할 수 있고, 

그림처럼 새로운 `각c`를 구할 수 있다.

![KakaoTalk_20220821_183401198_06](https://user-images.githubusercontent.com/89068148/185785949-f9cb23cc-d539-4800-91d3-f8aae21a0e15.jpg)

그림처럼, 앞서 구한 각의 누적합으로 다음 각을 표현하는 방식이다.



![KakaoTalk_20220821_183401198_07](https://user-images.githubusercontent.com/89068148/185790154-b5aaf787-96a5-42a9-b3f0-a0dcfbd0ea58.jpg)

따라서 우리가 필요한 중심점`way_point`의 좌표를 구하기 위해선, 

그림처럼 각의 누적합으로 삼각형에서 차량쪽의 각을 표현한다.

따라서 우리가 구하려는 중앙선 점들 중 하나를 `way[2]` 라고 예시를 들었을때, 

좌표의 경우 차량 중심점에서 x값이 `points[3] X cos(a + b + r)` 만큼 음수로 떨어져 있고, 

y값이 `points[3] X sin(a + b + r)` 만큼 떨어져 있다고 볼 수 있다.

<br>

<br>

#### 4. 도로 정보 및 장애물 표현하기

##### 초기 모델 : 차량(A) 와 장애물(X)의 모습을 볼수 있다.

![KakaoTalk_20220925_100134345_03](https://user-images.githubusercontent.com/89068148/192123944-dba92d69-9491-4f59-8d18-39ae75e70eb9.jpg)

<br>

<br>

# 3. 2차원 MAP 기반 장애물 극복 경로 찾기

<br>

#### 1차 시도 : 장애물 기반으로, 가능한 경로 수집

![KakaoTalk_20220925_100135314_01](https://user-images.githubusercontent.com/89068148/192124127-0e4932b2-7293-4d0d-bb50-19d30dcb1961.jpg)

그림처럼 장애물 기준으로 주행 가능한 통로 선을 그린다. 

해당 통로 선은 맵에서 표시된 1차원 배열이다.

장애물이 있는 곳은 **통로 없음**, 장애물이 없는 곳은 **통로 있음** 으로 표현한다.

그리고 현재 차량 기준으로, 

##### 가능한 통로점들 과 차량간 계산된 각이 가장 작은 것을 기준으로 선택한다.

##### 즉 현재 기준으로 차량이 가장 적게 핸들을 조향하도록 하는 통로를 선택

![ezgif com-gif-maker (3)](https://user-images.githubusercontent.com/89068148/192125449-056df290-189c-4a62-93b7-53a1dfec1d2f.gif)

##### 어떤 문제가 있는가 ?

1. 도로를 벗어나는 경로도 우선은 장애물을 회피할 수 있다고 판단된다.

   **solution > 실제 코드에 가능한 경로 생성을, 도로 밖은 제외하고 도로 안만 표현**

2. 장애물의 실제 크기를 그대로 맵에 넣기 보다는, 둘레 + 1 or 2 정도로 패딩을 주는 것이

   더욱 안정적으로 피할 수 있다.

   **solution > 장애물을 차량이 어느각도에서 바라보아도, 항상 여유있게 피할 수 있도록**

   **원의 형태 + 패딩 으로 장애물을 표현**

   ![KakaoTalk_20220925_100134345_29](https://user-images.githubusercontent.com/89068148/192124423-e1798b77-c630-417e-9b5d-e5cb6084e2e2.jpg)

<br>

<br>

#### 이슈 1 : 점으로 표현된 장애물 정보는 실제 크기를 반영하는가 ?

실제 장애물 크기보다 오차가 생긴다.

따라서 이 장애물을 실제보다 무조건 1 or 2 만큼 크게 표현한다.

즉 다시말해, 장애물과 맵으로 표현된 장애물의 크기들 간 생기는 오차보다

같거나 큰 보정값을 획득한다.

##### 발생한 문제

![KakaoTalk_20220925_100134345_05](https://user-images.githubusercontent.com/89068148/192124583-c5f3095b-55ff-45ae-aa25-deb5daf3e274.jpg)

그림과 같이, 보정이 지나치게 크면, 충분히 지나갈 수 있음에도 가능한 경로가 없다고 판단한다.

##### 옳바른 판단 결과 : 빨간 원을 가능한 경로라고 생각하고, 차량과의 조향각을 구한다.

![제목 없음](https://user-images.githubusercontent.com/89068148/192124601-be89a60a-42d8-431d-958c-9501d3bfb137.png)

##### 보정이 너무 크다면, 아래처럼 표현된다. 차량이 지나갈 경로가 없다고 판단됨.

![제목 없음](https://user-images.githubusercontent.com/89068148/192124661-b4c69dbd-19aa-4642-9093-597f5c93aa75.png)

##### 그래서 주행 맵과 장애물을 고려하여, 적당한 보정값이 필요하다. 

<br>

#### 이슈 2 : 차량각도가 항상 전방 수직으로 표현되는게 맞는가 ?

현재 표현된 맵을 보면, 차량은 항상 전방을 바라보고 있다.

직선구간에선 문제가 되지 않지만, 

만일 차량이 다른 방향을 바라보고 있다면, 

차량과 장애물을 피하기 위한 경로점 간 계산된 각도는, **실제 필요한 조향**과 다르다.

![KakaoTalk_20220925_104450742](https://user-images.githubusercontent.com/89068148/192124806-72570eec-8d62-4e33-ab49-80f14fb66650.jpg)

그림에서 차량이 세타 만큼 조향해야 원하는 경로(빨강)를 갈 수 있다고 나온다.

그러나 이미 차량은 해당 방향을 바라보고 있다.

현재 프로젝트는, 장애물과 차량, 도로정보등을 정밀지도와 비슷한 형태로 나타낼 수 있다.

그러나 **IMU 센서가 없기 떄문에 차량의 자세를 구할 수 없다**.

따라서 직선구간에선 차량이 도로와 평행하게 바라보고 있으므로, 

장애물을 피하기 위한 각도계산에 오차가 거의 없다.

그러나 곡선 구간은 오차가 생긴다.

해결과정은 아래로...

<br>

<br>

# 4. 발생한 문제와 해결방안

<br>

#### 받아오는 API 값이 튄다.

해당 시뮬레이션에서 고로가 이어지는 지점에, 특히 데이터 값이 튀는 현상이 있다.

이를 해결하기 위해 , 특정 구간에서는 새로운 정보를 바탕으로 장애물 정보를 갱신하지 않고

기존의 계산된 경로를 유지한다.

**가능한 이유**

API를 통해 받는 데이터 정보는 차량의 전방 200m까지 받을 수 있다.

즉, 앞 경로의 정보를 미리 저장할 수 있다.

<br>

#### 도로정보가 곡선일때, 왜곡된다.



이번 프로젝트의 가장 치명적인 약점이었다.

해결하기 위한 설계를 공유한다.

##### 곡선도로의 장애물 정보를 마치 직선도로 인것처럼 보정한다.

차량의 전방각도는 평균적으로 도로와 평행한 방향을 바라본다.

따라서 곡선형태의 도로를 직선 형태로 표현한다.

그럼 차량은 곡선일때 바라보던 방향이, 직선일때 위로 평행하게 바라본 것과 비슷하게 표현된다.

**차량의 z축(yaw값) 회전각을 특정 방향으로 고정하고, 주변 도로나 장애물등의 좌표를 회전행렬을 통해, 차량기준 정보로 표현하는 것과 비슷하다.**

![KakaoTalk_20220925_100134345_21](https://user-images.githubusercontent.com/89068148/192124954-076b3c74-61e5-4b95-b0b9-aeefbc200ec5.jpg)

<br>

![KakaoTalk_20220925_100134345_25](https://user-images.githubusercontent.com/89068148/192124965-f90f4ebd-c79c-447b-8ecb-23152dd9486a.jpg)

<br>

##### 테스트

![ezgif com-gif-maker (4)](https://user-images.githubusercontent.com/89068148/192125436-e3d632bc-e3d3-464c-9a79-27101fbed1f2.gif)
