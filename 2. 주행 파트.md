# 주행 파트

---



[0. 시작하기 앞서](#0-시작하기-앞서)

[1. 기본 제공 주행 코드](#1-기본-제공-주행-코드)

[1) 방향 제어](#1-방향-제어)

[2) 위치 제어](#2-위치-제어)

[3) 속도 제어](#3-속도-제어)

[4) 예외 상황 제어](#4-예외-상황-제어)

[2. Way Points 기반 주행](#2-way-points-기반-주행)



---

## 0. 시작하기 앞서

해당 문서는 각각의 트랙의 목적에 맞게 구성한 주행 코드에 대해 기술한 문서이다.  서로 다른 원리나 이론에 기반한 세 가지의 코드를 구현하였으며, 베이식, 결선 맵에 따라 서로 다른 주행을 구사하였다.

또한, API를 통해 확인되는 정보가 다소 부정확하고 정밀하지 않아서 정확한 계산을 통한 주행은 불가능했기 때문에, 완벽보다는 모나지 않게 작성된 코드임을 밝힌다.

<br>

기본적으로 주행에서 고려한 정보는 아래와 같다.

1. 속도가 약 100km/h를 넘어가면서 부터, 급격한 방향 전환의 경우 차체가 미끄러진다. steering 값이 0.3을 초과하면 미끄러지기 시작함을 trial-and-error로 파악하였다.
2. 

<br>

<br>

---

## 1. 기본 제공 주행 코드

아래는 제공된 기본 주행 코드이다.  주행 제어 코드는 아래 주행 코드의 분석에 기반하여 작성되었다.

<br>

```python
# my_car.py

half_load_width = self.half_road_limit - 1.25

angle_num = int(sensing_info.speed / 45)
ref_angle = sensing_info.track_forward_angles[angle_num] if angle_num > 0 else 0

middle_add = (sensing_info.to_middle / 80) * -1

throttle_factor = 0.6 / (abs(ref_angle) + 0.1)
if throttle_factor > 0.11: throttle_factor = 0.11
set_throttle = 0.7 + throttle_factor
if sensing_info.speed < 60: set_throttle = 0.9
if sensing_info.speed > 80: set_throttle = 0.6

steer_factor = sensing_info.speed * 1.5
if sensing_info.speed > 70: steer_factor = sensing_info.speed * 0.85
if sensing_info.speed > 100: steer_factor = sensing_info.speed * 0.7

set_steering = (ref_angle - sensing_info.moving_angle) / (steer_factor + 0.001)

set_steering += middle_add

full_throttle = True
emergency_brake = False

road_range = int(sensing_info.speed / 30)
for i in range(0, road_range):
    fwd_angle = abs(sensing_info.track_forward_angles[i])
    if fwd_angle > 45:
        full_throttle = False
    if fwd_angle > 80:
        emergency_brake = True
        break

set_brake = 0.0
if full_throttle == False:
    if sensing_info.speed > 100:
        set_brake = 0.3
    if sensing_info.speed > 120:
        set_throttle = 0.7
        set_brake = 0.7
    if sensing_info.speed > 130:
        set_throttle = 0.5
        set_brake = 1.0

if emergency_brake:
    if set_steering > 0:
        set_steering += 0.3
    else:
        set_steering -= 0.3
```

<br>

해당 코드에서 주행은 크게 3가지 부분으로 나누어진다.

<br>

#### 1) 방향 제어

```python
angle_num = int(sensing_info.speed / 45)
ref_angle = sensing_info.track_forward_angles[angle_num] if angle_num > 0 else 0

steer_factor = sensing_info.speed * 1.5
if sensing_info.speed > 70: steer_factor = sensing_info.speed * 0.85
if sensing_info.speed > 100: steer_factor = sensing_info.speed * 0.7

set_steering = (ref_angle - sensing_info.moving_angle) / (steer_factor + 0.001)
```

<br>

방향 제어에 사용된 변수는 아래와 같다.

<br>

- angle_num
  - 주행 제어를 위해 전방의 몇 번째 커브 값을 가져올 지를 판단하는 변수이다.
  - 당시의 주행 속도를 고려하여 빠를수록 먼 거리의 커브 값을 찾아올 수 있도록 판단되고 있다.
  - 속도가 45 km/h 보다 작을 경우에는 `0`, 45 ~ 90 km/h 은 `1`, 90 km/h 보다 빠를 경우에는 `2`가 된다.
- ref_angle
  - 앞서 구한 angle_num을 통해 참조할 커브 값으로, angle_num이 클수록 더 멀리 있는 구간의 도로 커브 값이 된다.
- steer_factor
  - 차량의 속도에 따라, 급격한 주행 각도 변화를 막기 위해 필요한 변수이다.
  - 속도가 70 km/h 이하인 경우 `speed * 1.5`, 70 ~ 100 km/h 인 경우 `speed * 0.85`, 100km/h 보다 빠른 경우 `speed * 0.7` 으로 제어된다.
  - 속도가 0인 경우 해당 값이 `0`이 되는 특징이 있다.
- set_steering
  - 직접적으로 주행 방향을 제어할 변수이다.
  - 전방의 도로 각도와 현재 차량의 주행각도를 비교하여, 두 각도의 차이(오차)를 줄이는 방향으로 제어가 이루어 진다.
  - 또한 steer_factor가 분모에 추가되어, 속도가 낮을수록 해당 값이 작아져 급격한 변화를 허용하도록 되어 있다.
  - 반대로 속도가 빠를수록 해당 값이 커져 완만하게 변화하도록 조정되고 있다.

<br>

항상 도로와 수평을 유지하는 것을 목표로 하며, 속도가 느리면 커브 가까이에서 급격하게 방향을 전환하고, 속도가 빠르면 커브 멀리서부터 천천히 방향을 전환하는 특징을 가지고 있다. 목표 값(ref_angle)과 현재 값(sensing_info.moving_angle)과의 차이(error)를 줄이는 방법이기 때문에 주행 제어 중에서는 PID 제어를 사용하기에 가장 적합한 코드이다.

<br>

#### 2) 위치 제어

```python
middle_add = (sensing_info.to_middle / 80) * -1
set_steering += middle_add
```

<br>위치 제어에 사용된 변수는 아래와 같다.

<br>

- middle_add
  - 중앙선과의 차이를 계산하여 이를 보정하는 변수이다.
  - 값은 `- (현재 중앙선으로부터의 거리 / 80)` 으로, 중앙선 기준 좌측에 있을 경우 0보다 크고, 우측에 있을 경우 0보다 작은 값이 된다.
  - 이를 set_steering에 더해줌으로써 차량의 위치가 중앙으로 수렴되도록 한다.

<br>

현재 차량 각도와 도로의 각도만 비교하여 주행한다면 차량이 도로 밖으로 벗어날 우려가 있다. 따라서 기본 제공 코드에서는 위와 같이 중앙선에서 벗어난 정도를 판단하여 항상 중앙선으로 위치가 수렴하도록 코드가 작성되어 있다. 

<br>

#### 3) 속도 제어

```python
throttle_factor = 0.6 / (abs(ref_angle) + 0.1)
if throttle_factor > 0.11: throttle_factor = 0.11
set_throttle = 0.7 + throttle_factor
if sensing_info.speed < 60: set_throttle = 0.9
if sensing_info.speed > 80: set_throttle = 0.6
```

<br>

속도 제어에 사용된 변수는 아래와 같다.

<br>

- throttle_factor
  - 전방의 커브 각도에 따라 가속을 조정해주는 변수이다.
  - 값은 `0.6 / (전방 각도 크기 + 0.1)` 으로, 각도가 클 수록 값이 작아진다.
  - 값이 `0.11`을 넘어가지 못하게 제한되어 있다.
- set_throttle
  - 직접적으로 가속을 제어할 변수이다.
  - 속도가 60 km/h 보다 느릴 경우 출력 값이 `0.9`로 고정된다(가속).
  - 속도가 60 ~ 80km/h 일 경우 출력 값은 `0.7 + throttle_factor`로 최대 `0.81`의 값을 가질 수 있다.
  - 속도가 80 km/h 보다 빠를 경우 출력 값이 `0.6`으로 고정된다(감속).

<br>

기본적인 주행 제어를 보여주기 위해 작성된 코드이기 때문에, 최대 속도가 80 km/h 로 제한되어 있음을 볼 수 있다. 커브에 진입할 때부터 steering이 크게 작용하여 set_throttle 값이 줄어든다.

<br>

#### 4) 예외 상황 제어

```python
full_throttle = True
emergency_brake = False

road_range = int(sensing_info.speed / 30)
for i in range(0, road_range):
    fwd_angle = abs(sensing_info.track_forward_angles[i])
    if fwd_angle > 45:
        full_throttle = False
    if fwd_angle > 80:
        emergency_brake = True
        break

set_brake = 0.0
if full_throttle == False:
    if sensing_info.speed > 100:
        set_brake = 0.3
    if sensing_info.speed > 120:
        set_throttle = 0.7
        set_brake = 0.7
    if sensing_info.speed > 130:
        set_throttle = 0.5
        set_brake = 1.0

if emergency_brake:
    if set_steering > 0:
        set_steering += 0.3
    else:
        set_steering -= 0.3
```

<br>

예외 상황 제어에 사용된 변수는 아래와 같다.

<br>

- full_throttle
  - 상단에서 적용된 set_throttle을 그대로 적용할 지, 아니면 추가로 제어할 지를 판단하는 변수이다.
  - 기본값은 `True`이고, `False`인 경우 set_throttle에 대한 추가적인 제어가 이루어 진다.
- emergency_brake
  - brake를 작동시킬 지, 작동시키지 않을 지를 판단하는 변수이다.
  - 기본값은 `False`이고, `True`인 경우 set_steering에 대한 추가적인 제어가 이루어 진다.
  - 각도가 80º 이상인 경우에 작동하므로, set_steering을 증가시켜 준다.
- road_range
  - 예외 상황 처리를 위해 전방의 몇 번째 커브값을 가져올 지를 판단하는 변수이다.
  - 당시의 주행 속도를 고려하여 빠를수록 먼 거리의 커브 값을 찾아올 수 있도록 판단되고 있다.
  - 속도가 30 km/h 보다 작을 경우에는 `0`, 30 ~ 60 km/h 은 `1`, 60 ~ 90 km/h 는 `2`가 된다.
- fwd_angle
  - 앞서 구한 road_range를 통해 참조할 커브 값으로, road_range가 클수록 더 멀리 있는 구간의 도로 커브 값이 된다.
  - road_range의 범위 내에서 한 번이라도 값이 45º보다 크면 full_throttle이 `False`가 된다.
  - road_range의 범위 내에서 한 번이라도 값이 80º보다 크면 emergency_brake가 `True`가 되며 이후 값은 확인하지 않는다.

- set_brake
  - 직접적으로 감속, 정지를 제어할 변수이다.
  - 기본값으로 `0.0`이 설정되어 있으며, full_throttle이 `True`이면 0 ~ 1 사이의 값으로 제어가 이루어진다.

<br>

급격한 커브에 대한 제어로, 각도가 45º보다 클 경우 현재 속도에 따라 감속의 정도를 조절하는 것을 볼 수 있다.

또한 예외 처리에서만 brake 값이 0이 아니고, 예외에 해당하지 않는 상황에서는 항상 brake가 0임을 알 수 있다.

즉 예외적인 상황 이외에서는 brake를 쓸 이유가 없다는 뜻이 되겠다.

<br>

이와 같은 middle 과 각도 기반 주행의 장점과 단점은 아래와 같다.

- 장점
  - 지속적으로 중앙선 위를 달리므로, 평균적으로 비슷한 기록을 유지할 수 있다. 안정적이다.
  - 마찬가지로, 도로를 벗어날 일이 없어 도로 이탈에 의한 패널티를 받지 않는다.
  - 각도에 기반하기 때문에 큰 각도에서도 느린 속도라면 코너링이 깔끔해진다.
- 단점
  - 제한 속도를 없앨 경우, 고속 주행을 할 때 steering 값이 너무 크다면 미끄러짐이 발생하여 오히려 불안정해진다.
  - 오로지 중앙선 기준으로 위치가 제어되므로, 이상적인 racing line과는 거리가 멀다. 비효율적인 움직임을 보인다.
  - 저속(특히 0에 가까운 속도)에서 steering_factor의 존재로 인해 steering 값이 매우 흔들림을 볼 수 있다.

따라서 위와 같은 단점들을 해결하기 위해서, 기본적으로 제공된 코드에서 벗어나 Way Points 기반 주행을 설계하게 되었다.

<br><br>

---

## 2. Way Points 기반 주행

해당 주행 코드는 이전 기수들의 주행 영상에 착안하여 구상하게 된 코드로, API에서 제공되는 way points를 기반으로 주행하는 코드이다. 원하는 위치의 way point 좌표를 계산하여, 해당 좌표를 목표로 steering을 제어하는 방법이기에, 마치 저 멀리서 누군가가 차를 끌어당기는 듯한 느낌의 주행이다. 어릴적 한 번쯤 본 '나들이 거북이'라는 거북이 모형이 가장 비슷한 비유가 될 것 같다.

상세 코드는 아래와 같다.

<br>

```python
# basic.py

car_controls.throttle = 1	# 빠른 주행을 위해 항상 가속한다.
car_controls.brake = 0		# 빠른 주행을 위해 항상 감속하지 않는다.


# way points 좌표 시작
middle = sensing_info.to_middle
spd = sensing_info.speed
plag = 1 if middle >= 0 else -1


points = [middle * plag,] + sensing_info.distance_to_way_points
angles = [0,] + [angle * plag for angle in sensing_info.track_forward_angles]
bo = [90, ]
ts = []
for i in range(20):
    C = 180 - bo[i] - (angles[i+1] - angles[i])
    temp = points[i] * math.sin(C * math.pi / 180) / points[i+1]
    if temp > 1:
        temp = 1
    elif temp < -1:
        temp = -1
    A =  math.asin(temp) * 180 / math.pi
    bo.append(A)
    ts.append(180 - C - A)

# way point 좌표
ways = []
for j in range(20): 
    ways.append([points[j+1] * math.sin(sum(ts[:j+1]) * math.pi / 180), - points[j+1] * plag * math.cos(sum(ts[:j+1]) * math.pi / 180)])

    
if spd < 120:
    tg = 5
elif spd < 140:
    tg = 7
else:
    tg = 9

theta = math.atan(ways[tg][1] / ways[tg][0]) * 180 / math.pi - sensing_info.moving_angle


if abs(angles[tg+2]) < 49 or abs(angles[tg+1]) < 47:
    if abs(angles[-1]) > 90 and spd > 165:
        if angles[-1] * plag >= 0:
            theta = math.atan((ways[tg][1] + 9) / ways[tg][0]) * 180 / math.pi - sensing_info.moving_angle
        else:
            theta = math.atan((ways[tg][1] - 9) / ways[tg][0]) * 180 / math.pi - sensing_info.moving_angle
        car_controls.steering = theta / 180
    else:
        if spd < 120:
            car_controls.steering = theta / 85
        else:
            car_controls.steering = theta / (spd * 0.95)
```

<br>

해당 코드의 작동 원리는 이와 같다.

1. 제공되는 way points 거리 정보와, 전방 도로 커브 값 track_forward_angles, 중앙선으로 부터의 거리 to_middle 값을 받는다.
2. 해당 정보들을 이용하여, 차량의 중심을 원점으로 한, 각 way point의 x, y 좌표 값과 각도를 구한다.
3. 속도에 따라 계수를 조정하여, 먼 거리의 way points를 타겟으로 삼아 그 위치를 향해 방향을 조정한다.

<br>

이를 위해 적용한 이론의 상세 내용은 아래와 같다.

<br>

<img src="https://user-images.githubusercontent.com/89068148/185785952-09ae9304-9911-41d3-a327-22c6cab131e3.jpg" alt="KakaoTalk_20220821_183401198" style="zoom:50%;" />

1. 차량의 중심, 차와 중앙선이 직각으로 만나는 점, 가장 가까이 있는 전방 way point, 총 세 점을 기반으로 삼각형을 만든다.

<br>

<img src="https://user-images.githubusercontent.com/89068148/185785953-74e12cd6-a7f8-4c58-b05c-2d8159b81abd.jpg" alt="KakaoTalk_20220821_183401198_01" style="zoom:50%;" />

2. 수평을 기준으로 하여, 총 180º에서 보정값 90º를 빼고, 추가로 현재 위치의 도로 커브 값과 다음 커브값의 차이를 구해서 뺀다. 제일 처음 기준으로는 angles[i] = 0이다. 이렇게 구한 값을 C라고 한다.

<br>

<img src="https://user-images.githubusercontent.com/89068148/185789419-9d051ec6-89b7-4ff7-9ceb-ac9304c36e39.jpg" alt="KakaoTalk_20220821_204211216" style="zoom:50%;" />

3. sin 법칙을 활용하여, 각 A를 구할 수 있다. 이는 아래의 sin 법칙을 기반으로 세운 식이다.

<br>

<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d80986c9d20c3eb3943d11776d454f6462b9b1ee" alt="sin법칙" style="zoom: 150%;" />

(출처 : [사인법칙](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B8_%EB%B2%95%EC%B9%99))

<br>

<img src="https://user-images.githubusercontent.com/89068148/185785956-16f7dfcf-0aeb-4e84-8a79-6a6980e2ad92.jpg" alt="KakaoTalk_20220821_183401198_03" style="zoom:50%;" />

4. 삼각형의 모든 내각의 합이 180º임을 이용하여, 나머지 하나의 각을 구한다.

<br>

<img src="https://user-images.githubusercontent.com/89068148/185785946-296cbf6d-e971-451e-acbe-bf62bc51fd2d.jpg" alt="KakaoTalk_20220821_183401198_04" style="zoom:50%;" />

5. 각 하나를 구했으면, 다음 way point를 기반으로 삼각형을 다시 그린다.

<br>

<img src="https://user-images.githubusercontent.com/89068148/185785947-d8f47e11-44b2-46b9-a24b-1dbf6f993be0.jpg" alt="KakaoTalk_20220821_183401198_05" style="zoom:50%;" />

6. 차량 중심과 직전 way point를 기반으로 선을 연장하고, 직전의 track_forward_angle을 연장한다. 그러면 직전의 A와 맞꼭지각이 형성되고, 추가로 이전 forward angle과 현재 forward angle을 기반으로 사이 각을 구한다. 이 둘을 빼면 다시 C를 구할 수 있다.이를 반복하면 사이각을 계속하여 구할 수 있다.

<br>

<img src="https://user-images.githubusercontent.com/89068148/185785949-f9cb23cc-d539-4800-91d3-f8aae21a0e15.jpg" alt="KakaoTalk_20220821_183401198_06" style="zoom:50%;" />

7. 모든 각을 구하면 위와 같이 내부의 α, β, γ 각을 전부 알 수 있다.

<br>

<img src="https://user-images.githubusercontent.com/89068148/185790154-b5aaf787-96a5-42a9-b3f0-a0dcfbd0ea58.jpg" alt="KakaoTalk_20220821_183401198_07" style="zoom:50%;" />

8. 최종적으로, 원하는 위치의 way point 좌표를 위와 같이 구할 수 있다. 이는 차량 중심 좌표를 [0, 0] 으로 하여 저장하였다. 

<br>

차량이 중앙선 기준 우측에 있을 경우에 대한 설명이지만, 차량이 좌측에 있을 때도 사용하는 변수만 조정하여 같은 방법으로 값을 구했다.

이 부분에 대한 코드는 아래와 같다.

<br>

```python
middle = sensing_info.to_middle		# 중앙선과 차량 중심 사이의 거리
spd = sensing_info.speed			# 차량의 현재 속도
plag = 1 if middle >= 0 else -1		# 차량이 중앙선 기준 좌측인가, 우측인가
```

- to_middle과 speed를 미리 사용하기 편하게 변수로 저장하고, 차량이 중앙선 기준 좌측인지 우측인지를 기록해둔다.

<br>

```python
points = [middle * plag,] + sensing_info.distance_to_way_points					# 처음 기준 값 + way point 까지의 거리 
angles = [0,] + [angle * plag for angle in sensing_info.track_forward_angles]	# 처음 기준 값 + angle 사이의 거리
bo = [90, ]																		# 처음 기준 값 + 추후 보정값으로 쓸 변수들
ts = []																			# 구한 각도를 저장할 배열
```

- 사용할 정보를 저장하고, 계산한 값을 저장할 배열을 미리 만들어 둔다.

<br>

```python
for i in range(20):
    C = 180 - bo[i] - (angles[i+1] - angles[i])						# 각 C를 구한다
    temp = points[i] * math.sin(C * math.pi / 180) / points[i+1]	# sinA의 값을 구한다
    if temp > 1:	# 차량이 중앙선 매우 가까이 있을 경우, 해당 값에 오차가 크게 생기기도 한다. 이를 벗어날 경우 강제로 고정해준다
        temp = 1
    elif temp < -1:
        temp = -1
    A =  math.asin(temp) * 180 / math.pi	# 각 A를 radian에서 º로 바꿔준다
    bo.append(A)	# 각 A를 다음 보정 값으로 사용한다.
    ts.append(180 - C - A)	# 삼각형의 원리로 각을 구해 저장한다.
```

- 해당 for문을 반복하면서 모든 way point에 대해 사이각을 저장해둔다.

<br>

```python
# way point 좌표
ways = []
for j in range(20): 
    ways.append([points[j+1] * math.sin(sum(ts[:j+1]) * math.pi / 180), - points[j+1] * plag * math.cos(sum(ts[:j+1]) * math.pi / 180)])
```

- 저장된 각도를 이용해, 차량의 위치에 따라 way points를 좌표로 변환해 저장한다.

<br>

```python
# 속도에 따라 목표 way point를 타겟팅
if spd < 120:
    tg = 5
elif spd < 140:
    tg = 7
else:
    tg = 9

# 목표 way points와 현재 차량 각도를 비교하여 목표로 해야할 각도를 찾는다.
theta = math.atan(ways[tg][1] / ways[tg][0]) * 180 / math.pi - sensing_info.moving_angle
```

- 목표 way point에 대해, 현재 각도와 way point의 각도를 이용하여 그 사이의 각도를 구한다.

<br>

```python
if abs(angles[tg+2]) < 49 or abs(angles[tg+1]) < 47:
    if abs(angles[-1]) > 90 and spd > 165:
        if angles[-1] * plag >= 0:
            theta = math.atan((ways[tg][1] + 9) / ways[tg][0]) * 180 / math.pi - sensing_info.moving_angle
        else:
            theta = math.atan((ways[tg][1] - 9) / ways[tg][0]) * 180 / math.pi - sensing_info.moving_angle
        car_controls.steering = theta / 180
    else:
        if spd < 120:
            car_controls.steering = theta / 85
        else:
            car_controls.steering = theta / (spd * 0.95)
```

- 그 너머의 각도를 참조하고,  각도의 크기에 따라 steering을 제어한다. 이는 후반부의 사용 코드 소개에서 더 자세하게 설명하겠다.

<br>

해당 코드에서 way points의 좌표를 구하지만, 이는 주행에 직접적으로 사용되진 않았다. 장애물 회피 로직에서 way points를 기반으로 장애물 좌표를 계산하는 데에 쓰였기 때문이다.

way point 기반 주행 로직을 구성하게 된 이유는, middle 기반 주행의 단점을 해소하기 위함이었다. 이러한 way point 기반 주행은 아래와 같은 장단점이 있다.

- 장점
  - 속도가 빠를수록 먼 거리의 way point를 참조하게 되고, 각도의 변화가 크지 않아 속도가 빨라도 미끄러짐이 거의 없다.
  - steering이 미세하게 변화하기 때문에 이상적인 racing line과 비슷하게 동작한다.

- 단점
  - 속도가 빠를수록 코너를 미리 움직이는 경향이 강하며, 이에 따라 도로 이탈 패널티가 빈번하게 발생한다. 최적화가 되어있지는 않다.
  - 저속의 흔들림은 해결할 수 있지만, 오히려 고속에서 steering이 0에 수렴하지 않아 직선주행에서 흔들리는 모습을 볼 수 있다.

middle 기반 주행에 비해서 고속의 안정감과 얕은 코너링에서의 효율성은 높아졌지만, 여전히 각도가 큰 코너에 대한 문제가 완전하게 해결되진 않았고, 오히여 직선주행에서의 불안정성은 더 증가하였다.

다만 실제 대회 맵에서 직선 주행 코스는 길지 않았기 때문에, 직선 주행의 흔들림은 드물게 나타났다. 따라서 고속에서의 큰 코너를 만나는 경우만 대비하면 될 것이라고 느꼈다. 이에 따라 아래와 같이 racing line 기반 주행 코드를 추가로 계획하게 되었다.

<br>

<br>

---

## 3. Racing Line 기반 주행













---

```python
# ob_middle.py

# 장애물 좌표
obs = []
near = abs(points[0] * math.cos((90 - angles[1]) * math.pi / 180)) + points[1] * math.cos(bo[1] * math.pi / 180)
for obj in sensing_info.track_forward_obstacles:
    d, m = obj['dist'] - near, obj['to_middle']
    if d <= 0:
        n, k = -1, obj['dist']
        ang = (90 - angles[n+1] * plag) * math.pi / 180
        obs.append([k * math.sin(ang) - m * math.cos(ang), -middle + k * math.cos(ang) + m * math.sin(ang)])
    else:
        n, k = int(d // 10), d % 10
        if n+2 > 10:
            break
        ang = (90 - angles[n+1] * plag) * math.pi / 180
        obs.append([ways[n][0] + k * math.sin(ang) - m * math.cos(ang), ways[n][1] + k * math.cos(ang) + m * math.sin(ang)])
```



<img src="https://user-images.githubusercontent.com/89068148/185785952-09ae9304-9911-41d3-a327-22c6cab131e3.jpg" alt="KakaoTalk_20220821_183401198" style="zoom:50%;" />

1. 차량의 중심, 차와 중앙선이 직각으로 만나는 점, 가장 가까이 있는 전방 way point, 총 세 점을 기반으로 삼각형을 만든다.

<br>

<img src="https://user-images.githubusercontent.com/95673624/185834613-9a288550-abc1-46f4-b5f4-b9f0181d0f2a.jpg" alt="KakaoTalk_20220822_124425156" style="zoom:50%;" />

2. 삼각형의 두 변의 길이와 두 각을 통해 near를 알아낸다.

<br>

<img src="https://user-images.githubusercontent.com/95673624/185834663-ffb3308c-bc34-4455-8a0f-896e5c940631.jpg" alt="KakaoTalk_20220822_124425156_01" style="zoom:50%;" />

3. 장애물의 dist가 near보다 작을 경우, 위와 같이 첫 번째 way point보다 장애물이 더 가까운 그림이 될 것이다.

<br>

<img src="https://user-images.githubusercontent.com/95673624/185834696-2b182dd3-5934-40de-8834-80da65b32226.jpg" alt="KakaoTalk_20220822_124425156_02" style="zoom:50%;" />

4. 이때, 차량 중심의 좌표를 [0, 0] 이라고 하면, 위와 같이 삼각형의 대각을 통해 장애물의 중심 위치를 파악할 수 있다. track_forward_angle을 이용하여, 시작점을 [-middle, 0]으로 잡고 계산한다.

<br>

<img src="https://user-images.githubusercontent.com/95673624/185834740-56f8f9bb-3d73-40b3-aa7b-32ff385fd527.jpg" alt="KakaoTalk_20220822_124425156_03" style="zoom:50%;" />

5. 같은 방법으로 장애물이 먼 위치에 있을 때에도, 시작점을 way[n] 으로 하는 것으로 같은 원리를 통해 좌표를 계산할 수 있다.

<br>

단점:

- 곡선일 때 부정확하다
  - 특히 way point 간의 직선거리가 10m가 아니고 곡선 거리가 10m이기 때문에, 물체가 멀리 있을수록 오차가 커진다.
  - 또한 way point 기반이기 때문에, sensing_info로 제공되는 정보가 튈 경우 영향을 받아 오차가 생긴다.
