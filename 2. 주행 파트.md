# 주행 파트

---

[0. 시작하기 앞서](#시작하기-앞서)



[2. Way Points 기반 주행](2.-way-points-기반-주행)

## 0. 시작하기 앞서

해당 문서는 각각의 트랙의 목적에 맞게 구성한 주행 코드에 대해 기술한 문서이다.  서로 다른 원리나 이론에 기반한 세 가지의 코드를 구현하였으며, 베이식, 결선 맵에 따라 서로 다른 주행을 구사하였다.

또한, API를 통해 확인되는 정보가 다소 부정확하고 정밀하지 않아서 정확한 계산을 통한 주행은 불가능했기 때문에, 완벽보다는 모나지 않게 작성된 코드임을 밝힌다.

<br>

기본적으로 주행에서 고려한 정보는 아래와 같다.

1. 속도가 약 100km/h를 넘어가면서 부터, 급격한 방향 전환의 경우 차체가 미끄러진다. steering 값이 0.3을 초과하면 미끄러지기 시작함을 trial-and-error로 파악하였다.
2. 

<br>

---

## 1. 기본 제공 주행 코드

아래는 제공된 기본 주행 코드이다.  주행 제어 코드는 아래 주행 코드의 분석에 기반하여 작성되었다.

<br>

```python
# my_car.py

half_load_width = self.half_road_limit - 1.25

angle_num = int(sensing_info.speed / 45)
ref_angle = sensing_info.track_forward_angles[angle_num] if angle_num > 0 else 0

middle_add = (sensing_info.to_middle / 80) * -1

throttle_factor = 0.6 / (abs(ref_angle) + 0.1)
if throttle_factor > 0.11: throttle_factor = 0.11
set_throttle = 0.7 + throttle_factor
if sensing_info.speed < 60: set_throttle = 0.9
if sensing_info.speed > 80: set_throttle = 0.6

steer_factor = sensing_info.speed * 1.5
if sensing_info.speed > 70: steer_factor = sensing_info.speed * 0.85
if sensing_info.speed > 100: steer_factor = sensing_info.speed * 0.7

set_steering = (ref_angle - sensing_info.moving_angle) / (steer_factor + 0.001)

set_steering += middle_add

full_throttle = True
emergency_brake = False

road_range = int(sensing_info.speed / 30)
for i in range(0, road_range):
    fwd_angle = abs(sensing_info.track_forward_angles[i])
    if fwd_angle > 45:
        full_throttle = False
    if fwd_angle > 80:
        emergency_brake = True
        break

set_brake = 0.0
if full_throttle == False:
    if sensing_info.speed > 100:
        set_brake = 0.3
    if sensing_info.speed > 120:
        set_throttle = 0.7
        set_brake = 0.7
    if sensing_info.speed > 130:
        set_throttle = 0.5
        set_brake = 1.0

if emergency_brake:
    if set_steering > 0:
        set_steering += 0.3
    else:
        set_steering -= 0.3
```

<br>

해당 코드에서 주행은 크게 3가지 부분으로 나누어진다.

<br>

#### 1) 방향 제어

```python
angle_num = int(sensing_info.speed / 45)
ref_angle = sensing_info.track_forward_angles[angle_num] if angle_num > 0 else 0

steer_factor = sensing_info.speed * 1.5
if sensing_info.speed > 70: steer_factor = sensing_info.speed * 0.85
if sensing_info.speed > 100: steer_factor = sensing_info.speed * 0.7

set_steering = (ref_angle - sensing_info.moving_angle) / (steer_factor + 0.001)
```

<br>

방향 제어에 사용된 변수는 아래와 같다.

<br>

- angle_num
  - 주행 제어를 위해 전방의 몇 번째 커브 값을 가져올 지를 판단하는 변수이다.
  - 당시의 주행 속도를 고려하여 빠를수록 먼 거리의 커브 값을 찾아올 수 있도록 판단되고 있다.
  - 속도가 45 km/h 보다 작을 경우에는 `0`, 45 ~ 90 km/h 은 `1`, 90 km/h 보다 빠를 경우에는 `2`가 된다.
- ref_angle
  - 앞서 구한 angle_num을 통해 참조할 커브 값으로, angle_num이 클수록 더 멀리 있는 구간의 도로 커브 값이 된다.
- steer_factor
  - 차량의 속도에 따라, 급격한 주행 각도 변화를 막기 위해 필요한 변수이다.
  - 속도가 70 km/h 이하인 경우 `speed * 1.5`, 70 ~ 100 km/h 인 경우 `speed * 0.85`, 100km/h 보다 빠른 경우 `speed * 0.7` 으로 제어된다.
  - 속도가 0인 경우 해당 값이 `0`이 되는 특징이 있다.
- set_steering
  - 직접적으로 주행 방향을 제어할 변수이다.
  - 전방의 도로 각도와 현재 차량의 주행각도를 비교하여, 두 각도의 차이(오차)를 줄이는 방향으로 제어가 이루어 진다.
  - 또한 steer_factor가 분모에 추가되어, 속도가 낮을수록 해당 값이 작아져 급격한 변화를 허용하도록 되어 있다.
  - 반대로 속도가 빠를수록 해당 값이 커져 완만하게 변화하도록 조정되고 있다.

<br>

항상 도로와 수평을 유지하는 것을 목표로 하며, 속도가 느리면 커브 가까이에서 급격하게 방향을 전환하고, 속도가 빠르면 커브 멀리서부터 천천히 방향을 전환하는 특징을 가지고 있다. 목표 값(ref_angle)과 현재 값(sensing_info.moving_angle)과의 차이(error)를 줄이는 방법이기 때문에 주행 제어 중에서는 PID 제어를 사용하기에 가장 적합한 코드이다.

<br>

#### 2) 위치 제어

```python
middle_add = (sensing_info.to_middle / 80) * -1
set_steering += middle_add
```

<br>위치 제어에 사용된 변수는 아래와 같다.

<br>

- middle_add
  - 중앙선과의 차이를 계산하여 이를 보정하는 변수이다.
  - 값은 `- (현재 중앙선으로부터의 거리 / 80)` 으로, 중앙선 기준 좌측에 있을 경우 0보다 크고, 우측에 있을 경우 0보다 작은 값이 된다.
  - 이를 set_steering에 더해줌으로써 차량의 위치가 중앙으로 수렴되도록 한다.

<br>

현재 차량 각도와 도로의 각도만 비교하여 주행한다면 차량이 도로 밖으로 벗어날 우려가 있다. 따라서 기본 제공 코드에서는 위와 같이 중앙선에서 벗어난 정도를 판단하여 항상 중앙선으로 위치가 수렴하도록 코드가 작성되어 있다. 

<br>

#### 3) 속도 제어

```python
throttle_factor = 0.6 / (abs(ref_angle) + 0.1)
if throttle_factor > 0.11: throttle_factor = 0.11
set_throttle = 0.7 + throttle_factor
if sensing_info.speed < 60: set_throttle = 0.9
if sensing_info.speed > 80: set_throttle = 0.6
```

<br>

속도 제어에 사용된 변수는 아래와 같다.

<br>

- throttle_factor
  - 전방의 커브 각도에 따라 가속을 조정해주는 변수이다.
  - 값은 `0.6 / (전방 각도 크기 + 0.1)` 으로, 각도가 클 수록 값이 작아진다.
  - 값이 `0.11`을 넘어가지 못하게 제한되어 있다.
- set_throttle
  - 직접적으로 가속을 제어할 변수이다.
  - 속도가 60 km/h 보다 느릴 경우 출력 값이 `0.9`로 고정된다(가속).
  - 속도가 60 ~ 80km/h 일 경우 출력 값은 `0.7 + throttle_factor`로 최대 `0.81`의 값을 가질 수 있다.
  - 속도가 80 km/h 보다 빠를 경우 출력 값이 `0.6`으로 고정된다(감속).

<br>

기본적인 주행 제어를 보여주기 위해 작성된 코드이기 때문에, 최대 속도가 80 km/h 로 제한되어 있음을 볼 수 있다. 커브에 진입할 때부터 steering이 크게 작용하여 set_throttle 값이 줄어든다.

<br>

#### 4) 예외 상황 제어

```python
full_throttle = True
emergency_brake = False

road_range = int(sensing_info.speed / 30)
for i in range(0, road_range):
    fwd_angle = abs(sensing_info.track_forward_angles[i])
    if fwd_angle > 45:
        full_throttle = False
    if fwd_angle > 80:
        emergency_brake = True
        break

set_brake = 0.0
if full_throttle == False:
    if sensing_info.speed > 100:
        set_brake = 0.3
    if sensing_info.speed > 120:
        set_throttle = 0.7
        set_brake = 0.7
    if sensing_info.speed > 130:
        set_throttle = 0.5
        set_brake = 1.0

if emergency_brake:
    if set_steering > 0:
        set_steering += 0.3
    else:
        set_steering -= 0.3
```

<br>

예외 상황 제어에 사용된 변수는 아래와 같다.

<br>

- full_throttle
  - 상단에서 적용된 set_throttle을 그대로 적용할 지, 아니면 추가로 제어할 지를 판단하는 변수이다.
  - 기본값은 `True`이고, `False`인 경우 set_throttle에 대한 추가적인 제어가 이루어 진다.
- emergency_brake
  - brake를 작동시킬 지, 작동시키지 않을 지를 판단하는 변수이다.
  - 기본값은 `False`이고, `True`인 경우 set_steering에 대한 추가적인 제어가 이루어 진다.
  - 각도가 80º 이상인 경우에 작동하므로, set_steering을 증가시켜 준다.
- road_range
  - 예외 상황 처리를 위해 전방의 몇 번째 커브값을 가져올 지를 판단하는 변수이다.
  - 당시의 주행 속도를 고려하여 빠를수록 먼 거리의 커브 값을 찾아올 수 있도록 판단되고 있다.
  - 속도가 30 km/h 보다 작을 경우에는 `0`, 30 ~ 60 km/h 은 `1`, 60 ~ 90 km/h 는 `2`가 된다.
- fwd_angle
  - 앞서 구한 road_range를 통해 참조할 커브 값으로, road_range가 클수록 더 멀리 있는 구간의 도로 커브 값이 된다.
  - road_range의 범위 내에서 한 번이라도 값이 45º보다 크면 full_throttle이 `False`가 된다.
  - road_range의 범위 내에서 한 번이라도 값이 80º보다 크면 emergency_brake가 `True`가 되며 이후 값은 확인하지 않는다.

- set_brake
  - 직접적으로 감속, 정지를 제어할 변수이다.
  - 기본값으로 `0.0`이 설정되어 있으며, full_throttle이 `True`이면 0 ~ 1 사이의 값으로 제어가 이루어진다.

<br>

급격한 커브에 대한 제어로, 각도가 45º보다 클 경우 현재 속도에 따라 감속의 정도를 조절하는 것을 볼 수 있다.

또한 예외 처리에서만 brake 값이 0이 아니고, 예외에 해당하지 않는 상황에서는 항상 brake가 0임을 알 수 있다.

즉 예외적인 상황 이외에서는 brake를 쓸 이유가 없다는 뜻이 되겠다.

<br>

이와 같은 middle 과 각도 기반 주행의 장점과 단점은 아래와 같다.

- 장점
  - 지속적으로 중앙선 위를 달리므로, 평균적으로 비슷한 기록을 유지할 수 있다. 안정적이다.
  - 마찬가지로, 도로를 벗어날 일이 없어 도로 이탈에 의한 패널티를 받지 않는다.
- 단점
  - 제한 속도를 없앨 경우, 고속 주행을 할 때 steering 값이 너무 크다면 미끄러짐이 발생하여 오히려 불안정해진다.
  - 오로지 중앙선 기준으로 위치가 제어되므로, 이상적인 racing line과는 거리가 멀다. 비효율적인 움직임을 보인다.

따라서 위와 같은 단점들을 해결하기 위해서, 기본적으로 제공된 코드에서 벗어나 Way Points 기반 주행을 설계하게 되었다.

<br>

---

## Way Points 기반 주행

해당 주행 코드는 이전 기수들의 주행 영상에 착안하여 구상하게 된 코드로, API에서 제공되는 way points를 기반으로 주행하는 코드이다.

상세 코드는 아래와 같다.

<br>

```python
# basic.py

car_controls.throttle = 1	# 빠른 주행을 위해 항상 가속한다.
car_controls.brake = 0		# 빠른 주행을 위해 항상 감속하지 않는다.


# way points 좌표 시작
middle = sensing_info.to_middle
spd = sensing_info.speed
plag = 1 if middle >= 0 else -1


points = [middle * plag,] + sensing_info.distance_to_way_points
angles = [0,] + [angle * plag for angle in sensing_info.track_forward_angles]
bo = [90, ]
ts = []
for i in range(20):
    C = 180 - bo[i] - (angles[i+1] - angles[i])
    temp = points[i] * math.sin(C * math.pi / 180) / points[i+1]
    if temp > 1:
        temp = 1
    elif temp < -1:
        temp = -1
    A =  math.asin(temp) * 180 / math.pi
    bo.append(A)
    ts.append(180 - C - A)

# way point 좌표
ways = []
for j in range(20): 
    ways.append([points[j+1] * math.sin(sum(ts[:j+1]) * math.pi / 180), - points[j+1] * plag * math.cos(sum(ts[:j+1]) * math.pi / 180)])

    
if spd < 120:
    tg = 5
elif spd < 140:
    tg = 7
else:
    tg = 9

theta = math.atan(ways[tg][1] / ways[tg][0]) * 180 / math.pi - sensing_info.moving_angle


if abs(angles[tg+2]) < 49 or abs(angles[tg+1]) < 47:
    if abs(angles[-1]) > 90 and spd > 165:
        if angles[-1] * plag >= 0:
            theta = math.atan((ways[tg][1] + 9) / ways[tg][0]) * 180 / math.pi - sensing_info.moving_angle
        else:
            theta = math.atan((ways[tg][1] - 9) / ways[tg][0]) * 180 / math.pi - sensing_info.moving_angle
        car_controls.steering = theta / 180
    else:
        if spd < 120:
            car_controls.steering = theta / 85
        else:
            car_controls.steering = theta / (spd * 0.95)
```

<br>

해당 코드의 작동 원리는 이와 같다.

1. 제공되는 way points 거리 정보와, 전방 도로 커브 값 track_forward_angles, 중앙선으로 부터의 거리 to_middle 값을 받는다.
2. 해당 정보들을 이용하여, 차량의 중심을 원점으로 한, 각 way point의 x, y 좌표 값과 각도를 구한다.
3. 속도에 따라 계수를 조정하여, 먼 거리의 way points를 